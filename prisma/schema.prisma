// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  output        = "../src/generated/prisma"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ========================================
// ENUMS
// ========================================

enum UserRole {
  ADMIN
  WORKER
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum CostType {
  MATERIALS
  LABOR
  OTHER
}

enum NotificationType {
  TASK_ASSIGNED
  TASK_COMPLETED
  TASK_OVERDUE
  SYSTEM
}

enum ReportPeriod {
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
  CUSTOM
}

enum RecurrencePattern {
  DAILY
  WEEKLY
  MONTHLY
}

enum AttendanceStatus {
  PRESENT
  ABSENT
  LATE
  SICK_LEAVE
  VACATION
}

// ========================================
// MODELS
// ========================================

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  password  String
  role      UserRole @default(WORKER)
  parentId  String?
  isActive  Boolean  @default(true)

  // Datos personales y laborales
  rut               String?
  phoneNumber       String?
  address           String?
  emergencyContact  String?
  emergencyPhone    String?
  jobTitle          String?
  department        String?
  hireDate          DateTime?
  birthDate         DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones jerárquicas (admin -> workers)
  parent  User?  @relation("UserHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  workers User[] @relation("UserHierarchy")

  // Relaciones con tareas
  createdTasks     Task[]     @relation("TaskCreator")
  assignedTasks    Task[]     @relation("TaskAssignees")
  completedSubtasks Subtask[] @relation("SubtaskCompleter")

  // Relaciones con notificaciones y reportes
  notifications Notification[]
  generatedReports Report[]

  // Relaciones con asistencia y desempeño
  attendanceRecords Attendance[]
  performanceEvaluations Performance[] @relation("PerformanceSubject")
  conductedEvaluations Performance[] @relation("PerformanceEvaluator")

  // Índices simples
  @@index([parentId])
  @@index([email])

  // Índices compuestos para queries optimizadas
  @@index([parentId, role])
  @@index([parentId, role, isActive])
}

model Task {
  id                 String              @id @default(cuid())
  title              String
  description        String?             @db.Text
  status             TaskStatus          @default(PENDING)
  priority           TaskPriority        @default(MEDIUM)
  category           String?
  scheduledStartDate DateTime
  scheduledEndDate   DateTime
  actualStartDate    DateTime?
  actualEndDate      DateTime?
  createdById        String

  // Campos de recurrencia
  isRecurring        Boolean             @default(false)
  recurrencePattern  RecurrencePattern?
  recurrenceEndDate  DateTime?
  parentTaskId       String?

  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt

  // Relaciones
  createdBy        User       @relation("TaskCreator", fields: [createdById], references: [id], onDelete: Cascade)
  assignedTo       User[]     @relation("TaskAssignees")
  subtasks         Subtask[]
  costs            TaskCost[]
  notifications    Notification[]

  // Auto-relación para tareas recurrentes
  parentTask       Task?      @relation("RecurringTasks", fields: [parentTaskId], references: [id], onDelete: SetNull)
  generatedTasks   Task[]     @relation("RecurringTasks")

  // Índices simples
  @@index([createdById])
  @@index([status])
  @@index([scheduledStartDate])
  @@index([parentTaskId])
  @@index([isRecurring])

  // Índices compuestos para queries optimizadas
  @@index([createdById, status])
  @@index([createdById, scheduledStartDate])
  @@index([status, scheduledEndDate])
  @@index([createdById, status, actualEndDate])
}

model Subtask {
  id            String    @id @default(cuid())
  taskId        String
  title         String
  order         Int
  isCompleted   Boolean   @default(false)
  completedById String?
  completedAt   DateTime?
  reportBefore  String?   @db.Text
  reportAfter   String?   @db.Text
  photosBefore  String[]
  photosAfter   String[]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relaciones
  task        Task  @relation(fields: [taskId], references: [id], onDelete: Cascade)
  completedBy User? @relation("SubtaskCompleter", fields: [completedById], references: [id], onDelete: SetNull)

  @@index([taskId])
  @@index([completedById])
}

model TaskCost {
  id          String   @id @default(cuid())
  taskId      String
  description String
  amount      Decimal  @db.Decimal(10, 2)
  costType    CostType
  date        DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relaciones
  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@index([taskId])
}

model Notification {
  id            String           @id @default(cuid())
  userId        String
  title         String
  message       String           @db.Text
  type          NotificationType
  isRead        Boolean          @default(false)
  relatedTaskId String?
  createdAt     DateTime         @default(now())

  // Relaciones
  user        User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  relatedTask Task? @relation(fields: [relatedTaskId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
}

model Report {
  id            String       @id @default(cuid())
  title         String
  period        ReportPeriod
  startDate     DateTime
  endDate       DateTime
  generatedById String
  content       Json
  createdAt     DateTime     @default(now())

  // Relaciones
  generatedBy User @relation(fields: [generatedById], references: [id], onDelete: Cascade)

  @@index([generatedById])
  @@index([startDate])
}

model Attendance {
  id        String           @id @default(cuid())
  userId    String
  date      DateTime         @db.Date
  checkIn   DateTime?
  checkOut  DateTime?
  status    AttendanceStatus @default(PRESENT)
  notes     String?          @db.Text
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  // Relaciones
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // NOTA: Se eliminó @@unique([userId, date]) para permitir múltiples registros por día
  // Esto permite múltiples ciclos de entrada/salida (ej: salida a almorzar)

  // Índices simples
  @@index([userId])
  @@index([date])
  @@index([status])

  // Índices compuestos para queries optimizadas
  @@index([userId, date, status])
  @@index([date, status])
  @@index([userId, date, checkOut]) // Para encontrar registros activos (sin checkOut)
}

model Performance {
  id            String   @id @default(cuid())
  userId        String
  evaluatorId   String
  period        String
  rating        Int      // 1-5 scale
  punctuality   Int?     // 1-5
  quality       Int?     // 1-5
  teamwork      Int?     // 1-5
  communication Int?     // 1-5
  comments      String?  @db.Text
  evaluatedAt   DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relaciones
  user      User @relation("PerformanceSubject", fields: [userId], references: [id], onDelete: Cascade)
  evaluator User @relation("PerformanceEvaluator", fields: [evaluatorId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([evaluatorId])
  @@index([evaluatedAt])
}
